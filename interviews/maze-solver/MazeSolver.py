# file: MazeSolver.py
# author: Adam Gross
# date: November 17, 2014
# description: This program solves mazes generated by https://challenge.flipboard.com/start

import urllib2
import json
import string

class Point:

    # initializes a Point object given a url
    def __init__(self, link):
        self.url = link
        json_data = fetch(link)
        self.end = json_data['end']
        self.adjacent = json_data['adjacent']
        self.letter = str(json_data['letter'])
        self.x = get_coord_from_url(link)[0]
        self.y = get_coord_from_url(link)[1]


# unpacks the JSON data from a given url and returns it as a dict
def fetch(url):
    req = urllib2.Request(url)
    response = urllib2.urlopen(req)
    json_data = response.read() 
    return json.loads(json_data)


# gets the maze identifier from a url
def get_maze_identifier(url):
    split_string = string.split(url, '=')[1]
    return split_string[:-2]


def get_coord_from_url(url):
    coord_str = string.split(url, '&')
    return (coord_str[1][2:], coord_str[2][2:])


# replaces the x and y value of a url to new values
def replace_x_y(url, old_x, old_y, new_x, new_y):
    intermediate = string.replace(url, 'x=' + str(old_x), 'x=' + str(new_x))
    return string.replace(intermediate, 'y=' + str(old_y), 'y=' + str(new_y))


# checks to see if @param point is held in container arr
def contains(arr, point):
    for p in arr:
        if p.url == point.url:
            return True
    return False


# solves the maze and returns the string representing
# the correct path to the end of the maze
def solve(point, answer_string, track):
    if point.end is True:
        return answer_string
    for coordinate in point.adjacent:
        new_point = Point(replace_x_y(point.url, point.x, point.y, coordinate['x'], coordinate['y']))
        if contains(track, new_point) is False:
            track.append(new_point)
            result = solve(new_point, answer_string + new_point.letter, track) 
            if result is not None:                  #ensures that non successful solves don't
                return result                       #return a None that hides the correct solution 


# checks a solution to a given maze
def check_solution(begin, answer_string):
    check_url = string.replace(begin.url, 'step', 'check')
    cut_end = check_url[:string.find(check_url, '&')]
    new_check_url = cut_end + '&guess=' + answer_string
    data = fetch(new_check_url)
    if data['success'] is True:
        return answer_string
    return 'Incorrect answer found.'


# runs main
def main():
    rerun = ''
    while 'n' not in rerun:
        start_url = raw_input('Input maze start url: ')
        begin = Point(start_url)
        answer_str = begin.letter
        track = [begin]
        print 'Solving...'
        answer = solve(begin, answer_str, track)
        print 'Checking answer...'
        print 'Answer to maze ' + get_maze_identifier(begin.url) + ' is:'
        print check_solution(begin, answer)
        rerun = raw_input('Would you like to run again? (y|n): ')
    print '\nDone.'

main()
